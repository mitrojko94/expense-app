{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Darko\\\\Desktop\\\\01-starting-setup\\\\src\\\\components\\\\Expenses\\\\ExpenseItem.js\";\n//Komponenta u Reactu je samo JS f-ja. Komponenta se pravi kombinacijom HTML, JS i CSS-a\n//Ime f-je skoro uvek da bude kao ime fajla. To je jako pozeljno\nimport \"./ExpenseItem.css\";\nimport ExpenseDate from \"./ExpenseDate\";\nimport Card from \"./UI/Card\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction ExpenseItem(props) {\n  //Uvek dobijam jedan parametar u React komponenti. Taj jedan parametar ce biti objekat koji sadrzi sve atribute kao properties. Moze se nazvati kao hoce, ali obicno je props da se kaze da je to objekat koji sadrzi sve vrednosti koje dobijamo za atribute\n  //U props objektu dobijamo key-value parove, sto radi React automatski. key ce biti imena atributa definisana u App.js(misli se na title, amount, date), a value ce biti njihove vrednosti\n  //key kom pristupam ovde, moram biti ime u fajlu App.js, bas isto ime, u suprotnom nece raditi\n  //U JS, za datume, mesec krece od 0, tako da je 0 januar\n  //   const expenseDate = new Date(2022, 3, 9);\n  //   const expenseTitle = \"Car Insurance\";\n  //   const expenseAmount = 294.67;\n  //   const month = props.date.toLocaleString(\"en-US\", { month: \"long\" });\n  //   const day = props.date.toLocaleString(\"en-US\", { day: \"2-digit\" });\n  //   const year = props.date.getFullYear();\n  //Imperativni nacin u JS - ne koristi se ovako u Reactu\n  //document.getElementById(\"root\").addEventListener()\n  //Definisem f-ju za klik pre naredbe return\n  const clickHandler = () => {\n    console.log(\"Clicked!!!\");\n  };\n\n  return /*#__PURE__*/_jsxDEV(Card, {\n    className: \"expense-item\",\n    children: [/*#__PURE__*/_jsxDEV(ExpenseDate, {\n      date: props.date\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"expense-item__description\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: [\"Title: \", props.title]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 32,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"expense-item__price\",\n        children: [\"Amount: $\", props.amount]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 33,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 31,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clickHandler,\n      children: \"Change Title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 29,\n    columnNumber: 5\n  }, this);\n} //Eksportovao sam ime f-je, da bih mogao da koristim. Posto je export default, prilikom importa moze biti bilo koje ime\n\n\n_c = ExpenseItem;\nexport default ExpenseItem; //U React fajlovima uvek moram imati jedan root element po returnu, tipa moram imati samo return div, ne mogu imati return div, div i slicno. To nije dozvoljeno, da ima vise root elemenata po returnu\n//Da bih resio taj problem, stavim sve to u jedan div, stavim u zagrade sve to i radice. Kao sto je uradjeno u primeru iznad\n//Jako je bitno imati samo jedan root element, a u okviru njega, moze biti mnogo elemenata\n//U Reactu kad hocu da dodam neki css fajl, importujem samo putanju do njega i dole kad stavljam u kod, ne koristim class, vec className\n//To je zato sto ovo nije cist HTML, lici na njega, ali to je specijalna sintaksa JSX uvedena od strane React tima. Ali na kraju, je i dalje JS kod, zato su neki atributi isti. Nije class, jer to sluzi za oznaku klase u JS, zato je className\n//Radice i sa class, ali uvek koristiti className\n//Stavim iznad naredbe return neke varijable sa podacima i ubacim te varijable u naredbu return, pomocu React sintakse za to, a sintaksa je {ime_varijable}\n//U {} mogu da stavim sta god, bice pokrenuto na ekranu, tipa 1 + 1 ili Math.random()\n//U liniji koda 13, stavio sam expenseDate.toISOString(), jer dobijam Date kao objekat, nemam nista na ekranu, a moram da koristim metodu toISOString(), da bih konvertovao u string i da bih imao ispis na ekranu\n//props = properties\n//Podaci ne bi smelo da se smestaju ovde, vec da se uvezu spolja. Sacuvati podatke u fajl App.js i odatle ih uvesti ovde, pomocu props\n//props se koristi stalno i jako je u upotrebi, jer omogucava prenos podataka iz jedne komponente u drugu\n//Prvi parametar je jezik na koji cu da postavim(tipa \"en-US\"), drugi parametar je objekat koji podesavam kako ce da bude formatiran(tipa month: \"long\"). Ovde se sve odnosi na metodu toLocalString(), linija koda 17\n//Ovo je najbolje raditi iznad naredbe return, tako sto to sve staviti u neku varijablu, uraditi sta hoces i posle dole pozvati tu varijablu. Tako sam ja uradio u primeru iznad\n//Nije bitno kada cemo praviti novu komponentu, ali je pozeljno da tima ako imamo neki element ovde(tipa date), a on ima jos neke pomocne konstante, imace dodatni stil, to treba staviti u novu komponentu\n//Ako imam komponente koje nemaju sadrzaj izmedju otvorenog i zatvorenog taga, moguce je napisati samo, tipa <ExpenseDate />. Ovako koristiti, pozeljno je\n//U liniji koda 21 stavio sam date={props.date}, jer sam prosledio podatke iz komponente ExpenseDate.js u komponentu ExpenseItem.js. To je uloga propsa. Naravno, ime koje stoji u ExpenseDate mora biti ime koje se prosledjuje u ExpenseItem\n//Posto sam uvezao Card i stavio za glavni div umesto div card, onda cu dobiti predefinisani stil za Card automatski\n//Kad ucitam nece se pojaviti nista, jer ne mogu da se koriste van boksa komponente kao wrappers\n\nvar _c;\n\n$RefreshReg$(_c, \"ExpenseItem\");","map":{"version":3,"sources":["C:/Users/Darko/Desktop/01-starting-setup/src/components/Expenses/ExpenseItem.js"],"names":["ExpenseDate","Card","ExpenseItem","props","clickHandler","console","log","date","title","amount"],"mappings":";AAAA;AACA;AACA,OAAO,mBAAP;AACA,OAAOA,WAAP,MAAwB,eAAxB;AACA,OAAOC,IAAP,MAAiB,WAAjB;;;AAEA,SAASC,WAAT,CAAqBC,KAArB,EAA4B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA,QAAMC,YAAY,GAAG,MAAM;AACzBC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ;AACD,GAFD;;AAIA,sBACE,QAAC,IAAD;AAAM,IAAA,SAAS,EAAC,cAAhB;AAAA,4BACE,QAAC,WAAD;AAAa,MAAA,IAAI,EAAEH,KAAK,CAACI;AAAzB;AAAA;AAAA;AAAA;AAAA,YADF,eAEE;AAAK,MAAA,SAAS,EAAC,2BAAf;AAAA,8BACE;AAAA,8BAAYJ,KAAK,CAACK,KAAlB;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAEE;AAAK,QAAA,SAAS,EAAC,qBAAf;AAAA,gCAA+CL,KAAK,CAACM,MAArD;AAAA;AAAA;AAAA;AAAA;AAAA,cAFF;AAAA;AAAA;AAAA;AAAA;AAAA,YAFF,eAQE;AAAQ,MAAA,OAAO,EAAEL,YAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YARF;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAYD,C,CAED;;;KAnCSF,W;AAoCT,eAAeA,WAAf,C,CAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA","sourcesContent":["//Komponenta u Reactu je samo JS f-ja. Komponenta se pravi kombinacijom HTML, JS i CSS-a\r\n//Ime f-je skoro uvek da bude kao ime fajla. To je jako pozeljno\r\nimport \"./ExpenseItem.css\";\r\nimport ExpenseDate from \"./ExpenseDate\";\r\nimport Card from \"./UI/Card\";\r\n\r\nfunction ExpenseItem(props) {\r\n  //Uvek dobijam jedan parametar u React komponenti. Taj jedan parametar ce biti objekat koji sadrzi sve atribute kao properties. Moze se nazvati kao hoce, ali obicno je props da se kaze da je to objekat koji sadrzi sve vrednosti koje dobijamo za atribute\r\n  //U props objektu dobijamo key-value parove, sto radi React automatski. key ce biti imena atributa definisana u App.js(misli se na title, amount, date), a value ce biti njihove vrednosti\r\n  //key kom pristupam ovde, moram biti ime u fajlu App.js, bas isto ime, u suprotnom nece raditi\r\n  //U JS, za datume, mesec krece od 0, tako da je 0 januar\r\n  //   const expenseDate = new Date(2022, 3, 9);\r\n  //   const expenseTitle = \"Car Insurance\";\r\n  //   const expenseAmount = 294.67;\r\n\r\n  //   const month = props.date.toLocaleString(\"en-US\", { month: \"long\" });\r\n  //   const day = props.date.toLocaleString(\"en-US\", { day: \"2-digit\" });\r\n  //   const year = props.date.getFullYear();\r\n\r\n  //Imperativni nacin u JS - ne koristi se ovako u Reactu\r\n  //document.getElementById(\"root\").addEventListener()\r\n\r\n  //Definisem f-ju za klik pre naredbe return\r\n  const clickHandler = () => {\r\n    console.log(\"Clicked!!!\");\r\n  };\r\n\r\n  return (\r\n    <Card className=\"expense-item\">\r\n      <ExpenseDate date={props.date} />\r\n      <div className=\"expense-item__description\">\r\n        <h2>Title: {props.title}</h2>\r\n        <div className=\"expense-item__price\">Amount: ${props.amount}</div>\r\n      </div>\r\n      {/*Ovo dodaje eventListener na dugme, da reaguje na klik. Prosledim mu value koja je uvek kod koji ce biti izvrsen kad se klikne dugme. Uvek je ta vrednost neka f-ja, to treba da mu prosledimo*/}\r\n      {/*Nikad ne stavljam zagrade f-ji, jer ako ih stavim JS izvrsice ovu f-ju kad se ova linija koda parsira, a to se parsira kad se JSX kod vrati*/}\r\n      <button onClick={clickHandler}>Change Title</button>\r\n    </Card>\r\n  );\r\n}\r\n\r\n//Eksportovao sam ime f-je, da bih mogao da koristim. Posto je export default, prilikom importa moze biti bilo koje ime\r\nexport default ExpenseItem;\r\n\r\n//U React fajlovima uvek moram imati jedan root element po returnu, tipa moram imati samo return div, ne mogu imati return div, div i slicno. To nije dozvoljeno, da ima vise root elemenata po returnu\r\n//Da bih resio taj problem, stavim sve to u jedan div, stavim u zagrade sve to i radice. Kao sto je uradjeno u primeru iznad\r\n//Jako je bitno imati samo jedan root element, a u okviru njega, moze biti mnogo elemenata\r\n\r\n//U Reactu kad hocu da dodam neki css fajl, importujem samo putanju do njega i dole kad stavljam u kod, ne koristim class, vec className\r\n//To je zato sto ovo nije cist HTML, lici na njega, ali to je specijalna sintaksa JSX uvedena od strane React tima. Ali na kraju, je i dalje JS kod, zato su neki atributi isti. Nije class, jer to sluzi za oznaku klase u JS, zato je className\r\n//Radice i sa class, ali uvek koristiti className\r\n\r\n//Stavim iznad naredbe return neke varijable sa podacima i ubacim te varijable u naredbu return, pomocu React sintakse za to, a sintaksa je {ime_varijable}\r\n//U {} mogu da stavim sta god, bice pokrenuto na ekranu, tipa 1 + 1 ili Math.random()\r\n\r\n//U liniji koda 13, stavio sam expenseDate.toISOString(), jer dobijam Date kao objekat, nemam nista na ekranu, a moram da koristim metodu toISOString(), da bih konvertovao u string i da bih imao ispis na ekranu\r\n\r\n//props = properties\r\n//Podaci ne bi smelo da se smestaju ovde, vec da se uvezu spolja. Sacuvati podatke u fajl App.js i odatle ih uvesti ovde, pomocu props\r\n//props se koristi stalno i jako je u upotrebi, jer omogucava prenos podataka iz jedne komponente u drugu\r\n\r\n//Prvi parametar je jezik na koji cu da postavim(tipa \"en-US\"), drugi parametar je objekat koji podesavam kako ce da bude formatiran(tipa month: \"long\"). Ovde se sve odnosi na metodu toLocalString(), linija koda 17\r\n//Ovo je najbolje raditi iznad naredbe return, tako sto to sve staviti u neku varijablu, uraditi sta hoces i posle dole pozvati tu varijablu. Tako sam ja uradio u primeru iznad\r\n\r\n//Nije bitno kada cemo praviti novu komponentu, ali je pozeljno da tima ako imamo neki element ovde(tipa date), a on ima jos neke pomocne konstante, imace dodatni stil, to treba staviti u novu komponentu\r\n\r\n//Ako imam komponente koje nemaju sadrzaj izmedju otvorenog i zatvorenog taga, moguce je napisati samo, tipa <ExpenseDate />. Ovako koristiti, pozeljno je\r\n\r\n//U liniji koda 21 stavio sam date={props.date}, jer sam prosledio podatke iz komponente ExpenseDate.js u komponentu ExpenseItem.js. To je uloga propsa. Naravno, ime koje stoji u ExpenseDate mora biti ime koje se prosledjuje u ExpenseItem\r\n\r\n//Posto sam uvezao Card i stavio za glavni div umesto div card, onda cu dobiti predefinisani stil za Card automatski\r\n//Kad ucitam nece se pojaviti nista, jer ne mogu da se koriste van boksa komponente kao wrappers\r\n"]},"metadata":{},"sourceType":"module"}