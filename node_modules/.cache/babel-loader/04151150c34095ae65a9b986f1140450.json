{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Darko\\\\Desktop\\\\01-starting-setup\\\\src\\\\components\\\\Expenses\\\\ExpenseItem.js\",\n    _s = $RefreshSig$();\n\n//Komponenta u Reactu je samo JS f-ja. Komponenta se pravi kombinacijom HTML, JS i CSS-a\n//Ime f-je skoro uvek da bude kao ime fajla. To je jako pozeljno\nimport \"./ExpenseItem.css\";\nimport ExpenseDate from \"./ExpenseDate\";\nimport Card from \"./UI/Card\";\nimport { useState } from \"react\"; //Ova f-ja useState nam omogucava da definisemo vrednosti kao state gde ce se promena ovih vrednosti odraziti na komponentu f-ju kad je pozvana opet\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction ExpenseItem(props) {\n  _s();\n\n  //Uvek dobijam jedan parametar u React komponenti. Taj jedan parametar ce biti objekat koji sadrzi sve atribute kao properties. Moze se nazvati kao hoce, ali obicno je props da se kaze da je to objekat koji sadrzi sve vrednosti koje dobijamo za atribute\n  //U props objektu dobijamo key-value parove, sto radi React automatski. key ce biti imena atributa definisana u App.js(misli se na title, amount, date), a value ce biti njihove vrednosti\n  //key kom pristupam ovde, moram biti ime u fajlu App.js, bas isto ime, u suprotnom nece raditi\n  //U JS, za datume, mesec krece od 0, tako da je 0 januar\n  //   const expenseDate = new Date(2022, 3, 9);\n  //   const expenseTitle = \"Car Insurance\";\n  //   const expenseAmount = 294.67;\n  //   const month = props.date.toLocaleString(\"en-US\", { month: \"long\" });\n  //   const day = props.date.toLocaleString(\"en-US\", { day: \"2-digit\" });\n  //   const year = props.date.getFullYear();\n  //Imperativni nacin u JS - ne koristi se ovako u Reactu\n  //document.getElementById(\"root\").addEventListener()\n  //Funkciju useState koristim unutar f-je ExpenseItem, unutar komponente. useState je jedan od React hooks koji su veoma bitni\n  useState();\n  let title = props.title; //Definisem f-ju za klik pre naredbe return. Uvek da se ime varijable koja sadrzi f-ju zavrsi sa recju Handler, to je praksa\n\n  const clickHandler = () => {\n    title = \"Updated\";\n    console.log(title);\n  };\n\n  return /*#__PURE__*/_jsxDEV(Card, {\n    className: \"expense-item\",\n    children: [/*#__PURE__*/_jsxDEV(ExpenseDate, {\n      date: props.date\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"expense-item__description\",\n      children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n        children: [\"Title: \", title]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"expense-item__price\",\n        children: [\"Amount: $\", props.amount]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: clickHandler,\n      children: \"Change Title\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 35,\n    columnNumber: 5\n  }, this);\n} //Eksportovao sam ime f-je, da bih mogao da koristim. Posto je export default, prilikom importa moze biti bilo koje ime\n\n\n_s(ExpenseItem, \"VhlnxxH3xh7Qs17KADUJ8wvRSZs=\");\n\n_c = ExpenseItem;\nexport default ExpenseItem; //U React fajlovima uvek moram imati jedan root element po returnu, tipa moram imati samo return div, ne mogu imati return div, div i slicno. To nije dozvoljeno, da ima vise root elemenata po returnu\n//Da bih resio taj problem, stavim sve to u jedan div, stavim u zagrade sve to i radice. Kao sto je uradjeno u primeru iznad\n//Jako je bitno imati samo jedan root element, a u okviru njega, moze biti mnogo elemenata\n//U Reactu kad hocu da dodam neki css fajl, importujem samo putanju do njega i dole kad stavljam u kod, ne koristim class, vec className\n//To je zato sto ovo nije cist HTML, lici na njega, ali to je specijalna sintaksa JSX uvedena od strane React tima. Ali na kraju, je i dalje JS kod, zato su neki atributi isti. Nije class, jer to sluzi za oznaku klase u JS, zato je className\n//Radice i sa class, ali uvek koristiti className\n//Stavim iznad naredbe return neke varijable sa podacima i ubacim te varijable u naredbu return, pomocu React sintakse za to, a sintaksa je {ime_varijable}\n//U {} mogu da stavim sta god, bice pokrenuto na ekranu, tipa 1 + 1 ili Math.random()\n//U liniji koda 13, stavio sam expenseDate.toISOString(), jer dobijam Date kao objekat, nemam nista na ekranu, a moram da koristim metodu toISOString(), da bih konvertovao u string i da bih imao ispis na ekranu\n//props = properties\n//Podaci ne bi smelo da se smestaju ovde, vec da se uvezu spolja. Sacuvati podatke u fajl App.js i odatle ih uvesti ovde, pomocu props\n//props se koristi stalno i jako je u upotrebi, jer omogucava prenos podataka iz jedne komponente u drugu\n//Prvi parametar je jezik na koji cu da postavim(tipa \"en-US\"), drugi parametar je objekat koji podesavam kako ce da bude formatiran(tipa month: \"long\"). Ovde se sve odnosi na metodu toLocalString(), linija koda 17\n//Ovo je najbolje raditi iznad naredbe return, tako sto to sve staviti u neku varijablu, uraditi sta hoces i posle dole pozvati tu varijablu. Tako sam ja uradio u primeru iznad\n//Nije bitno kada cemo praviti novu komponentu, ali je pozeljno da tima ako imamo neki element ovde(tipa date), a on ima jos neke pomocne konstante, imace dodatni stil, to treba staviti u novu komponentu\n//Ako imam komponente koje nemaju sadrzaj izmedju otvorenog i zatvorenog taga, moguce je napisati samo, tipa <ExpenseDate />. Ovako koristiti, pozeljno je\n//U liniji koda 21 stavio sam date={props.date}, jer sam prosledio podatke iz komponente ExpenseDate.js u komponentu ExpenseItem.js. To je uloga propsa. Naravno, ime koje stoji u ExpenseDate mora biti ime koje se prosledjuje u ExpenseItem\n//Posto sam uvezao Card i stavio za glavni div umesto div card, onda cu dobiti predefinisani stil za Card automatski\n//Kad ucitam nece se pojaviti nista, jer ne mogu da se koriste van boksa komponente kao wrappers\n//Kako React parsira JS kod, kako ga prikazuje na ekranu?\n//Komponenta je f-ja. Jedino specijalno u vezi nje je to sto vraca JSX kod. Posto je to f-ja, neko mora da je pozove. Mi je nismo ni jednom pozvali, vec koristili kao HTML elemente u JSX kodu\n//Koristeci nase komponente u JSX kodu, cinimo React svesnim nasih komponenti f-ja. Tipa, svesni smo nase ExpenseItem f-je i fajlu Expenses.js\n//Kad god React ocenjuje ovaj JSX kod, on ce pozvati ove komponente f-ja. Te komponente f-ja vraca JSX kod, koje se takodje ocenjuju, sve dok ne bude vise JSX koda za ocenjivanje\n//React poziva bilo koju f-ju komponente koju moze sresti u JSX kodu, onda poziva bilo koju f-ju koju te f-je mogu vratiti(bilo koji element koji te f-je mogu koristiti u svom JSX kodu) sve dok ne bude vise f-ja\n//Primer u fajlu Expenses.js\n//React ocenjuje ove ExpenseItem, poziva ExpenseItem komponentu f-je, izvrsava sav kod u njoj, susretne se sa JSX kodom, poziva Card f-ju i ovu ExpenseDate komponentu f-je\n//Zatim ide kroz ceo JSX kod u tim komponentama(misli se na ExpenseDate i Card) sve dok nema vise komponenti koda za pozivanje\n//Onda ponovo ocenjuje ceo resultat i prevodi ga u DOM instrukcije i nesto nam se prikazuje na ekranu(kao sto ja imam ovde). Tako React radi\n//Sve pocinje u fajlu index.js gde upucujemo na app komponentu. To je prva komponenta f-je koja ce biti pozvana i to se desava kad je React app ucitana na ekranu, sto se desava kad je neko posetio stranicu\n//Tako React ide kroz komponente, izvrsava sve komponente f-je i crta(prikazuje) nesto na ekranu. Jedini problem je sto React nikad ne ponavlja to\n//React ide kroz sve to kad je aplikacija doneta, ali posle toga je gotovo, nema azuriranja\n//Da bi to mogli da uradimo sa Reactom, tj. da promenimo neko stanje, tipa neko je kliknuo na dugme, pa da se promeni neki text ili boja, za to nam je potreban specijalan koncept \"state\"\n\nvar _c;\n\n$RefreshReg$(_c, \"ExpenseItem\");","map":{"version":3,"sources":["C:/Users/Darko/Desktop/01-starting-setup/src/components/Expenses/ExpenseItem.js"],"names":["ExpenseDate","Card","useState","ExpenseItem","props","title","clickHandler","console","log","date","amount"],"mappings":";;;AAAA;AACA;AACA,OAAO,mBAAP;AACA,OAAOA,WAAP,MAAwB,eAAxB;AACA,OAAOC,IAAP,MAAiB,WAAjB;AACA,SAASC,QAAT,QAAyB,OAAzB,C,CAAkC;;;;AAElC,SAASC,WAAT,CAAqBC,KAArB,EAA4B;AAAA;;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACAF,EAAAA,QAAQ;AACR,MAAIG,KAAK,GAAGD,KAAK,CAACC,KAAlB,CAlB0B,CAoB1B;;AACA,QAAMC,YAAY,GAAG,MAAM;AACzBD,IAAAA,KAAK,GAAG,SAAR;AACAE,IAAAA,OAAO,CAACC,GAAR,CAAYH,KAAZ;AACD,GAHD;;AAKA,sBACE,QAAC,IAAD;AAAM,IAAA,SAAS,EAAC,cAAhB;AAAA,4BACE,QAAC,WAAD;AAAa,MAAA,IAAI,EAAED,KAAK,CAACK;AAAzB;AAAA;AAAA;AAAA;AAAA,YADF,eAEE;AAAK,MAAA,SAAS,EAAC,2BAAf;AAAA,8BACE;AAAA,8BAAYJ,KAAZ;AAAA;AAAA;AAAA;AAAA;AAAA,cADF,eAEE;AAAK,QAAA,SAAS,EAAC,qBAAf;AAAA,gCAA+CD,KAAK,CAACM,MAArD;AAAA;AAAA;AAAA;AAAA;AAAA,cAFF;AAAA;AAAA;AAAA;AAAA;AAAA,YAFF,eAQE;AAAQ,MAAA,OAAO,EAAEJ,YAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YARF;AAAA;AAAA;AAAA;AAAA;AAAA,UADF;AAYD,C,CAED;;;GAxCSH,W;;KAAAA,W;AAyCT,eAAeA,WAAf,C,CAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["//Komponenta u Reactu je samo JS f-ja. Komponenta se pravi kombinacijom HTML, JS i CSS-a\r\n//Ime f-je skoro uvek da bude kao ime fajla. To je jako pozeljno\r\nimport \"./ExpenseItem.css\";\r\nimport ExpenseDate from \"./ExpenseDate\";\r\nimport Card from \"./UI/Card\";\r\nimport { useState } from \"react\"; //Ova f-ja useState nam omogucava da definisemo vrednosti kao state gde ce se promena ovih vrednosti odraziti na komponentu f-ju kad je pozvana opet\r\n\r\nfunction ExpenseItem(props) {\r\n  //Uvek dobijam jedan parametar u React komponenti. Taj jedan parametar ce biti objekat koji sadrzi sve atribute kao properties. Moze se nazvati kao hoce, ali obicno je props da se kaze da je to objekat koji sadrzi sve vrednosti koje dobijamo za atribute\r\n  //U props objektu dobijamo key-value parove, sto radi React automatski. key ce biti imena atributa definisana u App.js(misli se na title, amount, date), a value ce biti njihove vrednosti\r\n  //key kom pristupam ovde, moram biti ime u fajlu App.js, bas isto ime, u suprotnom nece raditi\r\n  //U JS, za datume, mesec krece od 0, tako da je 0 januar\r\n  //   const expenseDate = new Date(2022, 3, 9);\r\n  //   const expenseTitle = \"Car Insurance\";\r\n  //   const expenseAmount = 294.67;\r\n\r\n  //   const month = props.date.toLocaleString(\"en-US\", { month: \"long\" });\r\n  //   const day = props.date.toLocaleString(\"en-US\", { day: \"2-digit\" });\r\n  //   const year = props.date.getFullYear();\r\n\r\n  //Imperativni nacin u JS - ne koristi se ovako u Reactu\r\n  //document.getElementById(\"root\").addEventListener()\r\n\r\n  //Funkciju useState koristim unutar f-je ExpenseItem, unutar komponente. useState je jedan od React hooks koji su veoma bitni\r\n  useState();\r\n  let title = props.title;\r\n\r\n  //Definisem f-ju za klik pre naredbe return. Uvek da se ime varijable koja sadrzi f-ju zavrsi sa recju Handler, to je praksa\r\n  const clickHandler = () => {\r\n    title = \"Updated\";\r\n    console.log(title);\r\n  };\r\n\r\n  return (\r\n    <Card className=\"expense-item\">\r\n      <ExpenseDate date={props.date} />\r\n      <div className=\"expense-item__description\">\r\n        <h2>Title: {title}</h2>\r\n        <div className=\"expense-item__price\">Amount: ${props.amount}</div>\r\n      </div>\r\n      {/*Ovo dodaje eventListener na dugme, da reaguje na klik. Prosledim mu value koja je uvek kod koji ce biti izvrsen kad se klikne dugme. Uvek je ta vrednost neka f-ja, to treba da mu prosledimo*/}\r\n      {/*Nikad ne stavljam zagrade f-ji, jer ako ih stavim JS izvrsice ovu f-ju kad se ova linija koda parsira, a to se parsira kad se JSX kod vrati. To je previse rano, zato ide bez zagrada*/}\r\n      <button onClick={clickHandler}>Change Title</button>\r\n    </Card>\r\n  );\r\n}\r\n\r\n//Eksportovao sam ime f-je, da bih mogao da koristim. Posto je export default, prilikom importa moze biti bilo koje ime\r\nexport default ExpenseItem;\r\n\r\n//U React fajlovima uvek moram imati jedan root element po returnu, tipa moram imati samo return div, ne mogu imati return div, div i slicno. To nije dozvoljeno, da ima vise root elemenata po returnu\r\n//Da bih resio taj problem, stavim sve to u jedan div, stavim u zagrade sve to i radice. Kao sto je uradjeno u primeru iznad\r\n//Jako je bitno imati samo jedan root element, a u okviru njega, moze biti mnogo elemenata\r\n\r\n//U Reactu kad hocu da dodam neki css fajl, importujem samo putanju do njega i dole kad stavljam u kod, ne koristim class, vec className\r\n//To je zato sto ovo nije cist HTML, lici na njega, ali to je specijalna sintaksa JSX uvedena od strane React tima. Ali na kraju, je i dalje JS kod, zato su neki atributi isti. Nije class, jer to sluzi za oznaku klase u JS, zato je className\r\n//Radice i sa class, ali uvek koristiti className\r\n\r\n//Stavim iznad naredbe return neke varijable sa podacima i ubacim te varijable u naredbu return, pomocu React sintakse za to, a sintaksa je {ime_varijable}\r\n//U {} mogu da stavim sta god, bice pokrenuto na ekranu, tipa 1 + 1 ili Math.random()\r\n\r\n//U liniji koda 13, stavio sam expenseDate.toISOString(), jer dobijam Date kao objekat, nemam nista na ekranu, a moram da koristim metodu toISOString(), da bih konvertovao u string i da bih imao ispis na ekranu\r\n\r\n//props = properties\r\n//Podaci ne bi smelo da se smestaju ovde, vec da se uvezu spolja. Sacuvati podatke u fajl App.js i odatle ih uvesti ovde, pomocu props\r\n//props se koristi stalno i jako je u upotrebi, jer omogucava prenos podataka iz jedne komponente u drugu\r\n\r\n//Prvi parametar je jezik na koji cu da postavim(tipa \"en-US\"), drugi parametar je objekat koji podesavam kako ce da bude formatiran(tipa month: \"long\"). Ovde se sve odnosi na metodu toLocalString(), linija koda 17\r\n//Ovo je najbolje raditi iznad naredbe return, tako sto to sve staviti u neku varijablu, uraditi sta hoces i posle dole pozvati tu varijablu. Tako sam ja uradio u primeru iznad\r\n\r\n//Nije bitno kada cemo praviti novu komponentu, ali je pozeljno da tima ako imamo neki element ovde(tipa date), a on ima jos neke pomocne konstante, imace dodatni stil, to treba staviti u novu komponentu\r\n\r\n//Ako imam komponente koje nemaju sadrzaj izmedju otvorenog i zatvorenog taga, moguce je napisati samo, tipa <ExpenseDate />. Ovako koristiti, pozeljno je\r\n\r\n//U liniji koda 21 stavio sam date={props.date}, jer sam prosledio podatke iz komponente ExpenseDate.js u komponentu ExpenseItem.js. To je uloga propsa. Naravno, ime koje stoji u ExpenseDate mora biti ime koje se prosledjuje u ExpenseItem\r\n\r\n//Posto sam uvezao Card i stavio za glavni div umesto div card, onda cu dobiti predefinisani stil za Card automatski\r\n//Kad ucitam nece se pojaviti nista, jer ne mogu da se koriste van boksa komponente kao wrappers\r\n\r\n//Kako React parsira JS kod, kako ga prikazuje na ekranu?\r\n//Komponenta je f-ja. Jedino specijalno u vezi nje je to sto vraca JSX kod. Posto je to f-ja, neko mora da je pozove. Mi je nismo ni jednom pozvali, vec koristili kao HTML elemente u JSX kodu\r\n//Koristeci nase komponente u JSX kodu, cinimo React svesnim nasih komponenti f-ja. Tipa, svesni smo nase ExpenseItem f-je i fajlu Expenses.js\r\n//Kad god React ocenjuje ovaj JSX kod, on ce pozvati ove komponente f-ja. Te komponente f-ja vraca JSX kod, koje se takodje ocenjuju, sve dok ne bude vise JSX koda za ocenjivanje\r\n//React poziva bilo koju f-ju komponente koju moze sresti u JSX kodu, onda poziva bilo koju f-ju koju te f-je mogu vratiti(bilo koji element koji te f-je mogu koristiti u svom JSX kodu) sve dok ne bude vise f-ja\r\n\r\n//Primer u fajlu Expenses.js\r\n//React ocenjuje ove ExpenseItem, poziva ExpenseItem komponentu f-je, izvrsava sav kod u njoj, susretne se sa JSX kodom, poziva Card f-ju i ovu ExpenseDate komponentu f-je\r\n//Zatim ide kroz ceo JSX kod u tim komponentama(misli se na ExpenseDate i Card) sve dok nema vise komponenti koda za pozivanje\r\n//Onda ponovo ocenjuje ceo resultat i prevodi ga u DOM instrukcije i nesto nam se prikazuje na ekranu(kao sto ja imam ovde). Tako React radi\r\n//Sve pocinje u fajlu index.js gde upucujemo na app komponentu. To je prva komponenta f-je koja ce biti pozvana i to se desava kad je React app ucitana na ekranu, sto se desava kad je neko posetio stranicu\r\n//Tako React ide kroz komponente, izvrsava sve komponente f-je i crta(prikazuje) nesto na ekranu. Jedini problem je sto React nikad ne ponavlja to\r\n//React ide kroz sve to kad je aplikacija doneta, ali posle toga je gotovo, nema azuriranja\r\n//Da bi to mogli da uradimo sa Reactom, tj. da promenimo neko stanje, tipa neko je kliknuo na dugme, pa da se promeni neki text ili boja, za to nam je potreban specijalan koncept \"state\"\r\n"]},"metadata":{},"sourceType":"module"}